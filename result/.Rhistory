spatialCoords(spaData)
max_x <- dim(image)[1]
max_y <- dim(image)[2]
nbs <- image[max(0,round(x_pixel[i]-beta_half)):min(max_x, round(x_pixel[i]+beta_half+1)),
max(0,round(y_pixel[i]-beta_half)):min(max_y, round(y_pixel[i]+beta_half+1)),]
g <- rbind(g, apply(nbs,3,mean))
g
dim(g)
var.r <- var(g[1,])
var.r
var.b <- var(g[3,])
var.b <- var(g[,3])
var.b
var.r <- var(g[,1])
var.g <- var(g[,2])
var.b <- var(g[,3])
var.r
var.g
var.b
z <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
z
g
var.r <- var(g[,1])
var.g <- var(g[,2])
var.b <- var(g[,3])
print("Var of r, g, b = ", var.r, var.g, var.b)
print("Var of r, g, b = ")
print("Var of r, g, b = ",var.r, var.g, var.b)
print("Var of r, g, b = ",var.r)
var.r
<- var(g[,2])
var.g
var.b
var(1,2,3)
var(c(1,2,3))
var([1,2,3])
a <- c(1,2,3)
var(a)
a <- c(1,2,3,4,5)
var(a)
?var
var.r <- var(g[,1])*(length(x_pixel)-1)/length(x_pixel)
var.g <- var(g[,2])*(length(x_pixel)-1)/length(x_pixel)
var.b <- var(g[,3])*(length(x_pixel)-1)/length(x_pixel)
var.r
var.r <- var(g[,1])
var.r
var.r <- var(g[,1])*(dim(g)[1]-1)/dim(g)[1]
var.r
var.g <- var(g[,2])*(dim(g)[1]-1)/dim(g)[1]
var.b <- var(g[,3])*(dim(g)[1]-1)/dim(g)[1]
print("Var of r, g, b = ",var.r)
print(paste("Var of r, g, b = ", var.r))
print(paste("Var of r, g, b = ", var.r, var.g, var.b))
# raw score
z <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
z
# raw score
z0 <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
# scaled z score
z1 <- (z0 - mean(z0))/sd(z0)
z1
z0
sd(z0)
mean(z0)
?sd
install.packages(BiocGenerics)
install.packages("BiocGenerics")
install.packages("BiocGenerics")
library(BiocGenerics)
a <- c(1,2,3)
var(a)
BiocGenerics::var(a)
BiocGeneric::var(a)
BiocGenerics::var(a)
var.n <- function(array) {
variance <- var(array)*(length(array)-1)/length(array)
return(variance)
}
var.r <- var.n(g[,1])
var.g <- var.n(g[,2])
var.b <- var.n(g[,3])
var.r
var.g
var.b
sd.n <- function(array) {
return(sqrt(var.n(array)))
}
# scaled z score
z1 <- (z0 - mean(z0))/sd.n(z0)
z1
z_scale <- max(sd.n(x), sd.n(y))*alpha
z <- z1*z_scale
z
z_scale
alpha
sd.n(x)
x
x=x_pixel
y=y_pixel
z_scale <- max(sd.n(x), sd.n(y))*alpha
z_scale
z <- z1*z_scale
print("Var of x, y, z = ", var.n(x), var.n(y), var.n(z))
print(paste("Var of x, y, z = ", var.n(x), var.n(y), var.n(z)))
sd.n(x)
sd.n(y)
z
x
dim(x)
length(x)
mat <- rbind(x, y, z)
rbind(x, y)
dim(rbind(x, y))
mat[1,2]
mat[1,]
mat[,1]
mat <- as.data.frame(rbind(x, y))
mat
View)mat
View(mat)
mat <- as.data.frame(cbind(x, y))
mat$x
# x, y, x_pixel, y_pixel are lists
if (histology == TRUE){
stopifnot(!is.null(x_pixel) & !is.null(y_pixel) & !is.null(image))
stopifnot((length(x) != length(x_pixel)) & (length(y) != length(y_pixel)))
cat("Calculating adj matrix using histology image...")
# beta to control the range of neighborhood when calculate grey value for one spot
# alpha to control the color scale
beta_half <- round(beta/2,3)
g <- NULL
for (i in 1:length(x_pixel)){
max_x <- dim(image)[1]
max_y <- dim(image)[2]
nbs <- image[max(0,round(x_pixel[i]-beta_half)):min(max_x, round(x_pixel[i]+beta_half+1)),
max(0,round(y_pixel[i]-beta_half)):min(max_y, round(y_pixel[i]+beta_half+1)),]
# create average rgb for each block
g <- rbind(g, apply(nbs,3,mean))
}
var.r <- var.n(g[,1])
var.g <- var.n(g[,2])
var.b <- var.n(g[,3])
print(paste("Var of r, g, b = ", var.r, var.g, var.b))
# raw score
z0 <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
# scaled z score
z1 <- (z0 - mean(z0))/sd.n(z0)
z_scale <- max(sd.n(x), sd.n(y))*alpha
z <- z1*z_scale
print(paste("Var of x, y, z = ", var.n(x), var.n(y), var.n(z)))
mat <- as.data.frame(cbind(x, y, z))
}else {
cat("Calculating adj matrix using xy only...")
mat <- as.data.frame(cbind(x, y))
print("no")
}
length(x) != length(x_pixel)
length(x) == length(x_pixel)
# x, y, x_pixel, y_pixel are lists
if (histology == TRUE){
stopifnot(!is.null(x_pixel) & !is.null(y_pixel) & !is.null(image))
######## WHY?
stopifnot((length(x) == length(x_pixel)) & (length(y) == length(y_pixel)))
cat("Calculating adj matrix using histology image...")
# beta to control the range of neighborhood when calculate grey value for one spot
# alpha to control the color scale
beta_half <- round(beta/2,3)
g <- NULL
for (i in 1:length(x_pixel)){
max_x <- dim(image)[1]
max_y <- dim(image)[2]
nbs <- image[max(0,round(x_pixel[i]-beta_half)):min(max_x, round(x_pixel[i]+beta_half+1)),
max(0,round(y_pixel[i]-beta_half)):min(max_y, round(y_pixel[i]+beta_half+1)),]
# create average rgb for each block
g <- rbind(g, apply(nbs,3,mean))
}
var.r <- var.n(g[,1])
var.g <- var.n(g[,2])
var.b <- var.n(g[,3])
print(paste("Var of r, g, b = ", var.r, var.g, var.b))
# raw score
z0 <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
# scaled z score
z1 <- (z0 - mean(z0))/sd.n(z0)
z_scale <- max(sd.n(x), sd.n(y))*alpha
z <- z1*z_scale
print(paste("Var of x, y, z = ", var.n(x), var.n(y), var.n(z)))
mat <- as.data.frame(cbind(x, y, z))
}else {
cat("Calculating adj matrix using xy only...")
mat <- as.data.frame(cbind(x, y))
print("no")
}
i
head(mat)
nrow(mat)
ncol(mat)
parallel::detectCores()
n.cores <- parallel::detectCores() - 1
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
print(my.cluster)
doParallel::registerDoParallel(cl = my.cluster)
foreach::getDoParRegistered()
foreach::getDoParWorkers()
x <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
x
install.packages("foreach")
install.packages("foreach")
library(foreach)
a <- <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
a <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
foreach::getDoParRegistered()
parallel::detectCores()
n.cores <- parallel::detectCores() - 1
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
print(my.cluster)
doParallel::registerDoParallel(cl = my.cluster)
foreach::getDoParRegistered()
foreach::getDoParWorkers()
a <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
X <- mat
n <- nrow(X)
n
adj <- matrix(,nrow = n, ncol=n)
adj
head(matrix)
head(adj)
adj[3,3]
?foreach
parallel::stopCluster(cl = my.cluster)
i=1
j=2
length(x_pixel)
length(y_pixel)
X[i,]
x[j,]
X[j,]
head(X)
length(X[i,])
X[i,]-x[j,]
length(x[j,])
j
length(x[i,])
X[i,]-X[j,]
X[j,]-X[i,]
sum(X[i,]-X[j,])^2
sum((X[i,]-X[j,])^2)
254.7705 ^2+181.0081 ^2+197.9767^2
#------------------------------------------------------------------------------------------------
var.n <- function(array) {
variance <- var(array)*(length(array)-1)/length(array)
return(variance)
}
sd.n <- function(array) {
return(sqrt(var.n(array)))
}
pairwise.distance <- function(X) {
# run for loop in parallel
n.cores <- parallel::detectCores() - 1
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster)
n <- nrow(X)
adj <- matrix(,nrow = n, ncol=n)
foreach(i=1:n) %dopar% {
foreach(j=1:n)  %dopar% {
adj[i,j] <- sqrt(sum((X[i,]-X[j,])^2))
}
}
parallel::stopCluster(cl = my.cluster)
return(adj)
}
calculate.adj.matrix <- function(x, y, x_pixel = NULL, y_pixel = NULL, image = NULL,
beta = 49*scale.fac, alpha = 1, histology = TRUE){
# x, y, x_pixel, y_pixel are lists
if (histology == TRUE){
stopifnot(!is.null(x_pixel) & !is.null(y_pixel) & !is.null(image))
######## WHY?
stopifnot((length(x) == length(x_pixel)) & (length(y) == length(y_pixel)))
cat("Calculating adj matrix using histology image...")
# beta to control the range of neighborhood when calculate grey value for one spot
# alpha to control the color scale
beta_half <- round(beta/2,3)
g <- NULL
for (i in 1:length(x_pixel)){
max_x <- dim(image)[1]
max_y <- dim(image)[2]
nbs <- image[max(0,round(x_pixel[i]-beta_half)):min(max_x, round(x_pixel[i]+beta_half+1)),
max(0,round(y_pixel[i]-beta_half)):min(max_y, round(y_pixel[i]+beta_half+1)),]
# create average rgb for each block
g <- rbind(g, apply(nbs,3,mean))
}
var.r <- var.n(g[,1])
var.g <- var.n(g[,2])
var.b <- var.n(g[,3])
print(paste("Var of r, g, b = ", var.r, var.g, var.b))
# raw score
z0 <- (g[,1]*var.r+g[,2]*var.g+g[,3]*var.b)/(var.r + var.g + var.b)
# scaled z score
z1 <- (z0 - mean(z0))/sd.n(z0)
z_scale <- max(sd.n(x), sd.n(y))*alpha
z <- z1*z_scale
print(paste("Var of x, y, z = ", var.n(x), var.n(y), var.n(z)))
mat <- as.data.frame(cbind(x, y, z))
}else {
cat("Calculating adj matrix using xy only...")
mat <- as.data.frame(cbind(x, y))
}
return(pairwise.distance(mat))
}
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
library(ggplot2)
library(grid)
library(SpatialExperiment)
library(spatialLIBD)
library(tiff)
library(foreach)
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
install.packages("doSNOW")
install.packages("doParallel")
install.packages("doMPI")
install.packages("doSNOW")
install.packages("doParallel")
install.packages("doMPI")
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
library(doParallel)
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
foreach::getDoParRegistered()
foreach::getDoParWorkers()
parallel::stopCluster(cl = my.cluster)
adj <- calculate.adj.matrix(x=x_pixel,
y=y_pixel,
x_pixel=x_pixel,
y_pixel=y_pixel,
image=img.rgb,
beta=b,
alpha=s,
histology=TRUE)
pairwise.distance(mat)
X <- mat
# run for loop in parallel
n.cores <- parallel::detectCores() - 1
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster)
n <- nrow(X)
adj <- matrix(,nrow = n, ncol=n)
n
foreach(i=1:n) %dopar% (
foreach(j=1:n) %dopar% (
adj[i,j] <- sqrt(sum((X[i,]-X[j,])^2))
)
)
n <- nrow(X)
adj <- matrix(,nrow = n, ncol=n)
foreach(i=1:n) %:% (
foreach(j=1:n) %dopar% (
adj[i,j] <- sqrt(sum((X[i,]-X[j,])^2))
)
)
n <- nrow(X)
adj <- matrix(,nrow = n, ncol=n)
foreach(i=1:n) %do% (
foreach(j=1:n) %dopar% (
adj[i,j] <- sqrt(sum((X[i,]-X[j,])^2))
)
)
View(adj)
parallel::stopCluster(cl = my.cluster)
gc()
n <- nrow(X)
adj <- matrix(,nrow = n, ncol=n)
for (i in 1:n) {
for (j in 1:n){
adj[i,j] <- sqrt(sum((X[i,]-X[j,])^2))
}
}
library(ggplot2)
library(grid)
library(SpatialExperiment)
library(spatialLIBD)
library(tiff)
library(foreach)
library(doParallel)
library(scran)
library(scuttle)
source("../calculate_adj.R")
setwd("D:/desktop/Research/Stephanie/R/result")
source("../calculate_adj.R")
#   sampleid = "151673",
#   colors = libd_layer_colors,
#   ... = " LIBD Layers"
# )
# colData(spaData)
# rowData(spaData)
# dim(spaData)
# assay(spaData)
# spaData
# saveRDS(spaData, file = "spaData.rds")
spaData <- readRDS("spaData.rds")
img <- imgRaster(spaData,
sample_id = "151673",
image_id = "lowres")
# select captured samples
spaData <- spaData[, colData(spaData)$in_tissue==1]
rownames(spaData) <- lapply(rownames(spaData), toupper)
colnames(spaData) <- lapply(colnames(spaData), toupper)
# set coordinates
scale.fac <- scaleFactors(spaData)
x_array <- colData(spaData)$array_row
y_array <- colData(spaData)$array_col
x_pixel <- spatialCoords(spaData)[,2]*scale.fac
y_pixel <- spatialCoords(spaData)[,1]*scale.fac
# add rgb dimension
# array: rgb*pcol*prow
# after permutation:xp*yp*rgb
img.rgb <- aperm(array(col2rgb(img), dim=c(3,ncol(img),nrow(img))),c(3,2,1))
# 1. calculate adjacent matrix
# s parameter determines weight given to histology when calculating Euclidean distance between two spots
# s = 1: histology pixel intensity value has the same scale variance as the x,y coordinates
# higher s: higher weights to histology
s <- 1
# b parameter determines the area of each spot when extracting color intensity
b <- 49*scale.fac
source("../util.R")
#filter genes; PYTHON: scanpy filter: min cells, max cells, min counts, max counts
#exclude genes expressed in fewer than three spots
per.gene <- perFeatureQCMetrics(spaData)
discard <- per.gene$mean*dim(spaData)[2] < 3
spaData <- spaData[!discard,]
#exclude special genes: ERCC, MT
is.ERCC <- grep("ERCC", rownames(spaData))
is.mito <- grep("MT-", rownames(spaData))
spaData <- spaData[!is.ERCC | !is.mito,]
# 2. Spatial domain detection
# 2.1 Expression data processing
adj <- read.csv("adj.csv", header = TRUE)
source("../util.R")
# 2.2 Set hyper-parameters
# p: Percentage of total expression contributed by neighborhoods; average relative contribution of other spots for one spot across all spots
# l: Parameter to control p
p <- 0.5
# Find the l value given p
l <- search.l(p, adj, start = 0.01, end = 1000, tol = 0.01, max.run = 100)
l
